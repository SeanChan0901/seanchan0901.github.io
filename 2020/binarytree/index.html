<!DOCTYPE html>
<html lang="en-us">
  <head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  <meta name="author" content="小羊Sean">
  <meta name="description" content="NEVER SETTEL">
  
  
  
  
  <link rel="canonical" href="https://seanchan0901.github.io/2020/binarytree/" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
           二叉树 bianry tree 详解与实现 | 小羊Sean的blog
       
  </title>
  <meta name="title" content="二叉树 bianry tree 详解与实现 | 小羊Sean的blog">
    
  
  <link rel="stylesheet" href="/font/iconfont.css">
  <link rel="stylesheet" href="/css/main.min.css">


  
  
 

<script type="application/ld+json">
 "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "https:\/\/seanchan0901.github.io"
    },
    "articleSection" : "posts",
    "name" : "二叉树 bianry tree 详解与实现",
    "headline" : "二叉树 bianry tree 详解与实现",
    "description" : "二叉树（binaryTree）  一些关于树的基本概念 二叉树的定义 二叉树的特性 二叉树的描述  数组描述 链表描述   二叉树的常用操作 二叉树的遍历 二叉树链表描述的实现 二叉树的算法应用  信号放大器 并查集（union-find）      二叉树（binaryTree） 一些关于树的基本概念  一棵树的 高度（height） 或者 深度（depth） 是指树中级的个数。 一个 元素的度 是指其孩子的个数。 一棵树的度 是指其元素的度的最大值  二叉树的定义 一棵 二叉树（binary tree） $t$ 是有限个元素的集合（可以为空）。当二叉树非空时，其中有一个元素称为 根 ，余下的元素（如果有的话）被划分成两棵二叉树，分别称为 $t$ 的左子树和右子树。\n二叉树的特性   一棵二叉树有 $n$ 个元素，$n\x26gt;0$，他有 $n-1$ 条边。\n二叉树的每一个元素（除了根节点）有且仅有一个父节点，在子节点与父节点间有且仅有一条边，因此边数为 $n-1$ 。\n  一棵二叉树的高度为 $h$ ， $h\x26gt;=0$ ，它最少有 $h$ 个元素，最多有 $2^h-1$ 个元素。",
    "inLanguage" : "en-us",
    "author" : "小羊Sean",
    "creator" : "小羊Sean",
    "publisher": "小羊Sean",
    "accountablePerson" : "小羊Sean",
    "copyrightHolder" : "小羊Sean",
    "copyrightYear" : "2020",
    "datePublished": "2020-04-19 00:00:00 \x2b0000 UTC",
    "dateModified" : "2020-04-19 00:00:00 \x2b0000 UTC",
    "url" : "https:\/\/seanchan0901.github.io\/2020\/binarytree\/",
    "wordCount" : "1199",
    "keywords" : [ "Data Structures","binary tree","union-find", "小羊Sean的blog"]
}
</script>

  
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</head>

  

  <body class="">
    <div class="wrapper">
        <nav class="navbar">
    <div class="container">
        <div class="navbar-header header-logo">
        	<a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://seanchan0901.github.io">小羊Sean的blog</a>
        </div>
        <div class="menu navbar-right">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
                <a class="menu-item" href="/about/" title="About Hugo">About Hugo</a>
                
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
     <div class="container">
        <div class="navbar-header">
            <div>  <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://seanchan0901.github.io">小羊Sean的blog</a></div>
            <div class="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
                <a class="menu-item" href="/about/" title="About Hugo">About Hugo</a>
                
        </div>
    </div>
</nav>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-beta/dist/katex.min.css"/>
    	 <main class="main">
          <div class="container">
      		
<article class="post-warp" itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
        <h1 class="post-title" itemprop="name headline">二叉树 bianry tree 详解与实现</h1>
        <div class="post-meta">
                Written by <a itemprop="name" href="https://seanchan0901.github.io" rel="author">小羊Sean</a> with ♥ 
                <span class="post-time">
                on <time datetime=2020-04-19 itemprop="datePublished">April 19, 2020</time>
                </span>
                in
                <i class="iconfont icon-folder"></i>
                <span class="post-category">
                        <a href="https://seanchan0901.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"> 数据结构 </a>
                        
                </span>
        </div>
        <div id="wc" style="font-size: 0.8rem;text-align: center;">
            1200 
                Words | Read in about 6 Mins | total reading : <span id="busuanzi_value_page_pv"></span>
        </div>
    </header>

    <div class="post-content">
        

        
            
        

        
        
     
          
          
          

          
          
          

          <ul>
<li><a href="#%e4%ba%8c%e5%8f%89%e6%a0%91binarytree">二叉树（binaryTree）</a>
<ul>
<li><a href="#%e4%b8%80%e4%ba%9b%e5%85%b3%e4%ba%8e%e6%a0%91%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5">一些关于树的基本概念</a></li>
<li><a href="#%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e5%ae%9a%e4%b9%89">二叉树的定义</a></li>
<li><a href="#%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e7%89%b9%e6%80%a7">二叉树的特性</a></li>
<li><a href="#%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e6%8f%8f%e8%bf%b0">二叉树的描述</a>
<ul>
<li><a href="#%e6%95%b0%e7%bb%84%e6%8f%8f%e8%bf%b0">数组描述</a></li>
<li><a href="#%e9%93%be%e8%a1%a8%e6%8f%8f%e8%bf%b0">链表描述</a></li>
</ul>
</li>
<li><a href="#%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e5%b8%b8%e7%94%a8%e6%93%8d%e4%bd%9c">二叉树的常用操作</a></li>
<li><a href="#%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e9%81%8d%e5%8e%86">二叉树的遍历</a></li>
<li><a href="#%e4%ba%8c%e5%8f%89%e6%a0%91%e9%93%be%e8%a1%a8%e6%8f%8f%e8%bf%b0%e7%9a%84%e5%ae%9e%e7%8e%b0">二叉树链表描述的实现</a></li>
<li><a href="#%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e7%ae%97%e6%b3%95%e5%ba%94%e7%94%a8">二叉树的算法应用</a>
<ul>
<li><a href="#%e4%bf%a1%e5%8f%b7%e6%94%be%e5%a4%a7%e5%99%a8">信号放大器</a></li>
<li><a href="#%e5%b9%b6%e6%9f%a5%e9%9b%86union-find">并查集（union-find）</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="二叉树binarytree">二叉树（binaryTree）</h1>
<h2 id="一些关于树的基本概念">一些关于树的基本概念</h2>
<ul>
<li>一棵树的 <strong>高度（height）</strong> 或者 <strong>深度（depth）</strong> 是指树中级的个数。</li>
<li>一个 <strong>元素的度</strong> 是指其孩子的个数。</li>
<li><strong>一棵树的度</strong> 是指其元素的度的最大值</li>
</ul>
<h2 id="二叉树的定义">二叉树的定义</h2>
<p>一棵 <strong>二叉树（binary tree）</strong> $t$ 是有限个元素的集合（可以为空）。当二叉树非空时，其中有一个元素称为 <strong>根</strong> ，余下的元素（如果有的话）被划分成两棵二叉树，分别称为 $t$ 的左子树和右子树。</p>
<h2 id="二叉树的特性">二叉树的特性</h2>
<ol>
<li>
<p>一棵二叉树有 $n$ 个元素，$n&gt;0$，他有 $n-1$ 条边。</p>
<p>二叉树的每一个元素（除了根节点）有且仅有一个父节点，在子节点与父节点间有且仅有一条边，因此边数为 $n-1$ 。</p>
</li>
<li>
<p>一棵二叉树的高度为 $h$ ， $h&gt;=0$ ，它最少有 $h$ 个元素，最多有 $2^h-1$ 个元素。</p>
<p>因为每一级最少有 $1$ 个元素，因此元素的个数最少为 $h$ 。每个元素最多有 $2$ 个子节点，则第 $i$ 层节点元素最多为 $2^i-1$ 个， $i&gt;=0$ 。于是最多元素个数为 $\sum_{i=0}^h2^{i-1}=2^h-1$ 。</p>
</li>
<li>
<p>一棵二叉树有 $n$ 个元素， $n&gt;0$，他的高度最大为 $n$ ，最小高度为 $\lceil\log_2\left(n+1\right)\rceil$ 。</p>
</li>
<li>
<p>当高度为 $h$ 的二叉树恰好有 $2^h-1$ 个元素时，称其为 <strong>满二叉树（full binary tree）</strong> 。</p>
<p><img src="/images/blogFigure/binaryTree/figure1.png" alt="满二叉树" title="满二叉树"></p>
</li>
<li>
<p>当用一棵 <strong>满二叉树</strong> 从最底层开始，依次 <strong>从右到左</strong> 删除 $i$ 个叶子节点 $(i&lt;n)$ 。可以得到一棵 <strong>完全二叉树</strong> 。有 $n$ 个元素的完全二叉树其高度为 $\lceil\log_2\left(n+1\right)\rceil$ 。</p>
<p><img src="/images/blogFigure/binaryTree/figure2.png" alt="完全二叉树" title="完全二叉树"></p>
</li>
<li>
<p>设完全二叉树的一个元素编号为 $i$ ， $1&lt;=i&lt;=n$ 。 则有以下关系成立。</p>
<ul>
<li>如果 $i=1$ ，则该元素为二叉树的根。若 $i&gt;1$ ，则其父节点的编号为 $\lceil\ i/2  \rceil$ 。</li>
<li>如果 $2i&gt;n$ ，则该元素无左孩子，否则左孩子的编号为 $2i$ 。</li>
<li>如果 $2i+1&gt;n$ ，则该元素无右孩子，否则右孩子的编号为 $2i$ 。</li>
</ul>
</li>
</ol>
<h2 id="二叉树的描述">二叉树的描述</h2>
<h3 id="数组描述">数组描述</h3>
<p>按照特性  <strong>6</strong> 可以把二叉树看作是缺少了部分元素的完全二叉树。这种描述法最好坏情况下需要的空间是 $2^n-1$ ，因此只有当缺少的元素较少的时候，这种描述方法才是有用的。</p>
<p><img src="/images/blogFigure/binaryTree/figure3.png" alt="数组描述不完全二叉树"></p>
<h3 id="链表描述">链表描述</h3>
<p>二叉树最常用的表示方法为指针。每个元素用一个节点表示，节点有两个指针，分别指向左孩子和右孩子。
，用C++结构体binaryTreeNode来实现。没有孩子的节点对应的指针设为NULL。</p>
<p><img src="/images/blogFigure/binaryTree/figure5.png" alt="链表描述不完全二叉树"></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">binaryTreeNode</span> {
  T element;                      <span style="color:#75715e">// 储存的元素
</span><span style="color:#75715e"></span>  binaryTreeNode<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> leftChild;   <span style="color:#75715e">// 左孩子
</span><span style="color:#75715e"></span>  binaryTreeNode<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> rightChild;  <span style="color:#75715e">// 右孩子
</span><span style="color:#75715e"></span>  binaryTreeNode() { leftChild <span style="color:#f92672">=</span> rightChild <span style="color:#f92672">=</span> NULL; };
  binaryTreeNode(<span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> theElement) <span style="color:#f92672">:</span> element(theElement) {
    leftChild <span style="color:#f92672">=</span> rightChild <span style="color:#f92672">=</span> NULL;
  };
  binaryTreeNode(<span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> theElement, binaryTreeNode<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> theLeftChild,
                binaryTreeNode<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> theRightChild)
      <span style="color:#f92672">:</span> element(theElement) {
    leftChild <span style="color:#f92672">=</span> theLeftChild;
    rightChild <span style="color:#f92672">=</span> theRightChild;
  };
};
</code></pre></div><h2 id="二叉树的常用操作">二叉树的常用操作</h2>
<ul>
<li>确定高度</li>
<li>确定元素数目</li>
<li>复制</li>
<li>显示或者打印二叉树</li>
<li>确定两棵树是否一样</li>
<li>删除整棵二叉树树</li>
</ul>
<h2 id="二叉树的遍历">二叉树的遍历</h2>
<ul>
<li>前序遍历：每到达一个节点，先访问它。然后访问其左子树所有的节点，最后访问右子树所有的节点。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">// 前序遍历
</span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> preOrder(binaryTreeNode<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> t) {
  <span style="color:#75715e">// 遍历二叉树 *t
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (t <span style="color:#f92672">!=</span> NULL) {
    a_visit(t);               <span style="color:#75715e">// 访问
</span><span style="color:#75715e"></span>    preOrder(t<span style="color:#f92672">-&gt;</span>leftChild);   <span style="color:#75715e">// 遍历左子树
</span><span style="color:#75715e"></span>    preOrder(t<span style="color:#f92672">-&gt;</span>rightChile);  <span style="color:#75715e">// 遍历右子树
</span><span style="color:#75715e"></span>  }
};
</code></pre></div><ul>
<li>中序遍历：每到达一个节点，点访问其左子树的所有节点，再访问它，最后访问其右子树的所有节点。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">// 中序遍历
</span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> E<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> inOrder(binaryTreeNode<span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;*</span> t) {
  <span style="color:#75715e">// 遍历二叉树 *t
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (t <span style="color:#f92672">!=</span> NULL) {
    inOrder(t<span style="color:#f92672">-&gt;</span>leftChild);   <span style="color:#75715e">// 遍历左子树
</span><span style="color:#75715e"></span>    a_visit(t);              <span style="color:#75715e">// 访问
</span><span style="color:#75715e"></span>    inOrder(t<span style="color:#f92672">-&gt;</span>rightChile);  <span style="color:#75715e">// 遍历右子树
</span><span style="color:#75715e"></span>  }
};
</code></pre></div><ul>
<li>后续遍历：每到达一个节点，先访问其左子树所有的节点，然后访问其右子树所有节点，最后访问它。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">//后续遍历
</span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> postOrder(binaryTreeNode<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> t) {
  <span style="color:#75715e">// 遍历二叉树 *t
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (t <span style="color:#f92672">!=</span> NULL) {
    postOrder(t<span style="color:#f92672">-&gt;</span>leftChild);   <span style="color:#75715e">// 遍历左子树
</span><span style="color:#75715e"></span>    postOrder(t<span style="color:#f92672">-&gt;</span>rightChile);  <span style="color:#75715e">// 遍历右子树
</span><span style="color:#75715e"></span>    a_visit(t);                <span style="color:#75715e">// 访问
</span><span style="color:#75715e"></span>  }
};
</code></pre></div><ul>
<li>
<p>层次遍历：按照层次从上到下访问，每一层从左到右依次访问所有节点。</p>
<p>利用队列来完成层次遍历的操作，开始时将根节点放到队列中，只要队列不空，从队列中取出队首元素，将他的孩子加到队列尾。</p>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">// 层次遍历
</span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> levelOrder(binaryTreeNode<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*</span> t) {
  <span style="color:#75715e">// 层次遍历二叉树 *t
</span><span style="color:#75715e"></span>  arrayQueue<span style="color:#f92672">&lt;</span>binaryTreeNode<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;*&gt;</span> q;  <span style="color:#75715e">// 用一个队列来完成
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">while</span> (t <span style="color:#f92672">!=</span> NULL) {
    a_visit(t);

    <span style="color:#75715e">// 将t的孩子插入队列
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (t<span style="color:#f92672">-&gt;</span>leftChild <span style="color:#f92672">!=</span> NULL) {
      q.push(t<span style="color:#f92672">-&gt;</span>leftChild);
    }
    <span style="color:#66d9ef">if</span> (t<span style="color:#f92672">-&gt;</span>rightChile <span style="color:#f92672">!=</span> NULL) {
      q.push(t<span style="color:#f92672">-&gt;</span>rightChile);
    }

    <span style="color:#75715e">// 提取下一个要访问的节点
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">try</span> {
      t <span style="color:#f92672">=</span> q.front();
    } <span style="color:#66d9ef">catch</span> (queueEmpty) {
      std<span style="color:#f92672">::</span>cerr <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;levelOrder finished&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
      <span style="color:#66d9ef">return</span>;  <span style="color:#75715e">// 如果队列空则证明遍历完毕
</span><span style="color:#75715e"></span>    }
    q.pop();
  }
};

</code></pre></div><h2 id="二叉树链表描述的实现">二叉树链表描述的实现</h2>
<ul>
<li>
<p>抽象数据类型BinaryTree：</p>
<p>二叉树遍历方法的参数类型为<code>void (*)(T*)</code>，接受一个函数作为参数，作为参数的函数，其返回类型是<code>void</code> ， 其参数类型是<code>T*</code> 。</p>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">binaryTree</span> {
 <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
  <span style="color:#66d9ef">virtual</span> <span style="color:#f92672">~</span>binaryTree() {}
  <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">empty</span>() <span style="color:#66d9ef">const</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">size</span>() <span style="color:#66d9ef">const</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  <span style="color:#75715e">// 接受的参数为一个函数
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 该函数的格式为：1）返回类型为void 2)接受一个T类型的指针
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 这个函数由一个函数指针*来访问
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">preOrder</span>(<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)(T<span style="color:#f92672">*</span>)) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;    <span style="color:#75715e">// 前序遍历
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">inOrder</span>(<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)(T<span style="color:#f92672">*</span>)) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;     <span style="color:#75715e">// 中序遍历
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">postOrder</span>(<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)(T<span style="color:#f92672">*</span>)) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;   <span style="color:#75715e">// 后续遍历
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">levelOrder</span>(<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)(T<span style="color:#f92672">*</span>)) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;  <span style="color:#75715e">// 层次遍历
</span><span style="color:#75715e"></span>};
</code></pre></div><ul>
<li>
<p>二叉树的链式描述：linkedBinaryTree</p>
<p>派生于抽象类binaryTree，节点类型为binaryTreeNode</p>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> E<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">linkedBinaryTree</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> binaryTree<span style="color:#f92672">&lt;</span>binaryTreeNode<span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> {
 <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
  <span style="color:#75715e">// 构造函数和析构函数
</span><span style="color:#75715e"></span>  linkedBinaryTree() {
    root <span style="color:#f92672">=</span> NULL;
    treeSize <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  };
  <span style="color:#f92672">~</span>linkedBinaryTree() { erase(); };

  <span style="color:#75715e">// 工具函数
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">empty</span>() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> treeSize <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>; };
  <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">size</span>() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> treeSize; };

  <span style="color:#75715e">// 成员遍历函数,接受一个访问函数，按照前序遍历访问
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">preOrder</span>(<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>theVisit)(binaryTreeNode<span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;*</span>));
  <span style="color:#75715e">// 成员遍历函数,接受一个访问函数，按照中序遍历访问
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">inOrder</span>(<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>theVisit)(binaryTreeNode<span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;*</span>));
  <span style="color:#75715e">// 成员遍历函数,接受一个访问函数，按照前后遍历访问
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">postOrder</span>(<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>theVisit)(binaryTreeNode<span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;*</span>));
  <span style="color:#75715e">// 成员遍历函数,接受一个访问函数，按照层次序遍历访问
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">levelOrder</span>(<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)(binaryTreeNode<span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;*</span>));
  <span style="color:#75715e">// 获取树的高度
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">erase</span>() {  <span style="color:#75715e">// 后续遍历删除一棵树
</span><span style="color:#75715e"></span>    postOrder(dispose);
    root <span style="color:#f92672">=</span> NULL;
    treeSize <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  };

  <span style="color:#75715e">// 建树
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">makeTree</span>(<span style="color:#66d9ef">const</span> E<span style="color:#f92672">&amp;</span> element, linkedBinaryTree<span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;&amp;</span> left,
                linkedBinaryTree<span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;&amp;</span> right);
  <span style="color:#75715e">// 前序输出函数
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">preOrderOutput</span>() {
    preOrder(output);
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
  };

  <span style="color:#75715e">// 中序输出函数
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">inOrderOutput</span>() {
    inOrder(output);
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
  };

  <span style="color:#75715e">// 后续输出函数
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">postOrderOutput</span>() {
    postOrder(output);
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
  };

 <span style="color:#66d9ef">protected</span><span style="color:#f92672">:</span>
  binaryTreeNode<span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;*</span> root;                      <span style="color:#75715e">// 根节点
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> treeSize;                                 <span style="color:#75715e">// 树的节点个数
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">static</span> <span style="color:#a6e22e">void</span> (<span style="color:#f92672">*</span>visit)(binaryTreeNode<span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;*</span>);     <span style="color:#75715e">// 访问函数
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">preOrder</span>(binaryTreeNode<span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;*</span> t);   <span style="color:#75715e">// 前序
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">inOrder</span>(binaryTreeNode<span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;*</span> t);    <span style="color:#75715e">// 中序
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">postOrder</span>(binaryTreeNode<span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;*</span> t);  <span style="color:#75715e">// 后序
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dispose</span>(binaryTreeNode<span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;*</span> t) {
    <span style="color:#66d9ef">delete</span> t;
  }  <span style="color:#75715e">// 删除函数：删除一个节点
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">output</span>(binaryTreeNode<span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;*</span> t) {
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> t<span style="color:#f92672">-&gt;</span>element <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
  };  <span style="color:#75715e">// 输出函数，输出一个节点
</span><span style="color:#75715e"></span>};
</code></pre></div><h2 id="二叉树的算法应用">二叉树的算法应用</h2>
<h3 id="信号放大器">信号放大器</h3>
<ol>
<li>
<p>问题描述</p>
<p>在一些分布式网络中，资源从生产地送往其他地方，这些资源我们可以统称为 <em><strong>信号（signal）</strong></em> ，在信号从信号源传递到消费点的传输过程中，仅能容忍一定范围内的信号衰减。为了使信号衰减不超过容忍值，应在网络中放置 <em><strong>信号放大器（signal booster）</strong></em> ，使其信号恢复至 <em><strong>与源点相同</strong></em> 。</p>
<ul>
<li>目标：使得放大器的数目最少的同时保证信号衰减不超过给定的容忍值。</li>
</ul>
<p><img src="/images/blogFigure/binaryTree/figure6.png" alt="树形分布网络"></p>
</li>
<li>
<p>求解策略</p>
<ul>
<li>
<p>设 <code>degradeFromParent(i)</code> 表示节点 $i$ 与其父节点之间的衰减量。首先设置限制条件，如果 <code>degradeFromParent(i)</code> 大于容忍值，那么即使在i处放置了信号放大器，信号量的衰减依然要超过容忍值。例如，容忍值为2则在图中节点 $r$ 放置了放大器，信号量的衰减也不会小于等于2。</p>
</li>
<li>
<p>从节点i到子树的每一个叶子都有一个衰减量，把这些衰减量的最大者记为 <code>degradeToLeaf(i)</code> ，特别的，当 $i$ 为叶子结点时，<code>degradeToLeaf(i) == 0</code> 。那么对于其他的非叶子节点 $i$， 其 <code>degradeToLeaf(i)</code> 可以这样描述（ $j$ 为 $i$ 的孩子）:</p>
<p>$degradeToLeaf(i)=max(degradeToLeaf(j)+degradeFromParent(j))$</p>
</li>
</ul>
</li>
<li>
<p>代码</p>
</li>
</ol>
<ul>
<li>
<p>用结构 <code>booster</code> 作为节点存储的元素</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">booster</span> {
  <span style="color:#66d9ef">int</span> degradeToLeaf;      <span style="color:#75715e">// 到达叶子树时的衰减量
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> degradeFromParent;  <span style="color:#75715e">// 从双亲节点到该节点的衰减量
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">bool</span> boosterHere;       <span style="color:#75715e">// 是否放置信号放大器
</span><span style="color:#75715e"></span>
  booster(<span style="color:#66d9ef">int</span> theDegradeFromParent) {
    degradeFromParent <span style="color:#f92672">=</span> theDegradeFromParent;
    degradeToLeaf<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
  };

  booster() {
    degradeFromParent <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    degradeToLeaf <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  }
  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">output</span>(std<span style="color:#f92672">::</span>ostream<span style="color:#f92672">&amp;</span> out) <span style="color:#66d9ef">const</span> {
    out <span style="color:#f92672">&lt;&lt;</span> boosterHere <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">&lt;&lt;</span> degradeToLeaf <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">&lt;&lt;</span> degradeFromParent
        <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
  };
};
</code></pre></div></li>
<li>
<p>放大器设置函数</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">placeBoosters</span>(binaryTreeNode<span style="color:#f92672">&lt;</span>booster<span style="color:#f92672">&gt;*</span> x) {
  <span style="color:#75715e">// 计算*x的衰减量，若小于容忍值，则在x的字节点放置一个放大器
</span><span style="color:#75715e"></span>  x<span style="color:#f92672">-&gt;</span>element.degradeToLeaf <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;  <span style="color:#75715e">// 初始化x处的衰减量
</span><span style="color:#75715e"></span>
  <span style="color:#75715e">//  计算x的左子树的衰减量,若大于容忍值则在x的左孩子处放置一个放大器
</span><span style="color:#75715e"></span>  binaryTreeNode<span style="color:#f92672">&lt;</span>booster<span style="color:#f92672">&gt;*</span> y <span style="color:#f92672">=</span> x<span style="color:#f92672">-&gt;</span>leftChild;
  <span style="color:#66d9ef">if</span> (y <span style="color:#f92672">!=</span> NULL) {
    <span style="color:#75715e">// x有一棵左子树
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> degradation <span style="color:#f92672">=</span> y<span style="color:#f92672">-&gt;</span>element.degradeToLeaf <span style="color:#f92672">+</span> y<span style="color:#f92672">-&gt;</span>element.degradeFromParent;
    <span style="color:#66d9ef">if</span> (degradation <span style="color:#f92672">&gt;</span> tolerance) {  <span style="color:#75715e">// 在x处的衰减量大于容忍值
</span><span style="color:#75715e"></span>      <span style="color:#75715e">// 在y处放置一个放大器
</span><span style="color:#75715e"></span>      y<span style="color:#f92672">-&gt;</span>element.boosterHere <span style="color:#f92672">=</span> true;
      x<span style="color:#f92672">-&gt;</span>element.degradeToLeaf <span style="color:#f92672">=</span> y<span style="color:#f92672">-&gt;</span>element.degradeFromParent;  <span style="color:#75715e">// 更新x的衰减量
</span><span style="color:#75715e"></span>    } <span style="color:#66d9ef">else</span>
      x<span style="color:#f92672">-&gt;</span>element.degradeToLeaf <span style="color:#f92672">=</span>
          degradation;  <span style="color:#75715e">// 在x处的衰减量大于容忍值，则更新衰减量
</span><span style="color:#75715e"></span>  }
  y <span style="color:#f92672">=</span> x<span style="color:#f92672">-&gt;</span>rightChild;
  <span style="color:#66d9ef">if</span> (y <span style="color:#f92672">!=</span> NULL) {
    <span style="color:#75715e">// x有一棵右子树
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> degradation <span style="color:#f92672">=</span> y<span style="color:#f92672">-&gt;</span>element.degradeToLeaf <span style="color:#f92672">+</span> y<span style="color:#f92672">-&gt;</span>element.degradeFromParent;
    <span style="color:#66d9ef">if</span> (degradation <span style="color:#f92672">&gt;</span> tolerance) {  <span style="color:#75715e">// 在x处的衰减量大于容忍值
</span><span style="color:#75715e"></span>      <span style="color:#75715e">// 在y处放置一个放大器
</span><span style="color:#75715e"></span>      y<span style="color:#f92672">-&gt;</span>element.boosterHere <span style="color:#f92672">=</span> true;
      degradation <span style="color:#f92672">=</span> y<span style="color:#f92672">-&gt;</span>element.degradeFromParent;  <span style="color:#75715e">// 更新x的衰减量
</span><span style="color:#75715e"></span>    }
    <span style="color:#75715e">// 对比左右子树衰减量，取最大值作为x的衰减量
</span><span style="color:#75715e"></span>    x<span style="color:#f92672">-&gt;</span>element.degradeToLeaf <span style="color:#f92672">=</span>
        (degradation <span style="color:#f92672">&gt;</span> x<span style="color:#f92672">-&gt;</span>element.degradeToLeaf <span style="color:#f92672">?</span> degradation
                                                : x<span style="color:#f92672">-&gt;</span>element.degradeToLeaf);
  }
};
</code></pre></div></li>
<li>
<p>用后续遍历来设置信号放大器</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">// 后缀设置信号放大器 v为一棵二叉树
</span><span style="color:#75715e"></span>  v.postOrder(placeBoosters);
</code></pre></div><p><img src="/images/blogFigure/binaryTree/figure8_1.png" alt="放置放大器后的结果"></p>
</li>
</ul>
<h3 id="并查集union-find">并查集（union-find）</h3>
<ol>
<li>
<p>问题描述</p>
<p>并查集是我们在解决 <strong>很多算法问题</strong> 时都要用的。现给出以下几个定义：</p>
<ol>
<li>
<p><em><strong>等价类</strong></em>：</p>
<p>假定一个具有 $n$ 个元素的集合 $U=1,2,3,4,&hellip;,n$ 和一个具有 $r$ 个关系的集合 $R=(i_1,j_1),(i_2,j_2),&hellip;,(i_r,j_r)$ ，
关系 $R$ 是一个 <em><strong>等价关系</strong></em> 当且仅当以下条件为真：</p>
<ul>
<li>对于所有的  $a \in U$，有 $(a,a) \in R$（关系是自反的）</li>
<li>$(a,b) \in R$，当且仅当 $(b,a) \in R$ （关系是对称的）</li>
<li>若$(a,b) \in R$ 且 $(b,a) \in R$ ,则有$(a,c) \in R$ （关系是传递的）</li>
</ul>
<p>如果$(a,b) \in R$ ，则元素 $a$ 和 $b$ 是等价的。所谓 <em><strong>等价类（equivalence class）</strong></em> 是指互相等价的元素的最大集合。“最大”意味着不存在类外的元素与哪类的元素等价。一个元素只能属于一个等价类。</p>
</li>
<li>
<p><em><strong>离线等价类（offline equivalence class）</strong></em></p>
<p>已知 $n$ 和 $R$ ，确定所有等价类。</p>
</li>
<li>
<p><em><strong>在线等价类（online equivalence class）</strong></em></p>
<p>初始时有 $n$ 个元素，每个元素都属于一个独立的等价类，需要执行以下操作：</p>
<ol>
<li><code>combine(a,b)</code> 把包含 $a$ 和 $b$ 的等价类合并成一个等价类。</li>
<li><code>find(theElement)</code> 确定元素 $theElement$ 属于哪一个类。</li>
</ol>
</li>
</ol>
<p>于是 <em><strong>并查集（union-find）</strong></em> 就是一系列的 <code>find(theElement)</code> 和 <code>combine(a,b)</code> 组合操作，把不同的类合并成同一等价类。</p>
</li>
<li>
<p>求解策略</p>
<p>用树来解决并查集的问题，其中每一个集合表示为一棵树，一开始 $n$ 个元素为单独的只含一个节点的树。把根元素作为集合的标志符。因此 <code>find(3)</code> 的返回值是20，<code>find(1)</code> 的返回值也是20；<code>find(25)</code> 的返回值是16。当且仅当元素 $i$ 和 $j$ 属于同一个集合时，有 <code>find(i) == find(j)</code> 。那么为了确定元素theElement属于哪个集合，我们从元素theElement开始，沿着节点到向上移动，直到跟节点为止。我们用一个 <code>parent[]</code> 来存放节点的父节点，<code>parent[i]</code>存放的就是节点 $i$ 的父节点的位置。根节点的 <code>parent</code> 被设为0。</p>
<p><img src="/images/blogFigure/binaryTree/figure9.png" alt="用树表示的分离集合1"></p>
<p><img src="/images/blogFigure/binaryTree/figure10.png" alt="用树表示的分离集合2"></p>
</li>
<li>
<p>代码</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">initialize</span>(<span style="color:#66d9ef">int</span> numberOfElements) {
    parent <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[numberOfElements <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> e <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; e <span style="color:#f92672">&lt;=</span> numberOfElements; e<span style="color:#f92672">++</span>) {
      parent[e] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    }
  }  <span style="color:#75715e">// 初始化在线等价类
</span><span style="color:#75715e"></span>
  <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">find</span>(<span style="color:#66d9ef">int</span> theElement) {
    <span style="color:#66d9ef">while</span> (parent[theElement] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) theElement <span style="color:#f92672">=</span> parent[theElement];
    <span style="color:#66d9ef">return</span> theElement;
  }  <span style="color:#75715e">// 返回元素theElement所在的树的根（所属等价类）
</span><span style="color:#75715e"></span>
  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">unite</span>(<span style="color:#66d9ef">int</span> rootA, <span style="color:#66d9ef">int</span> rootB) {
    <span style="color:#66d9ef">if</span> (rootA <span style="color:#f92672">!=</span> rootB) parent[rootB] <span style="color:#f92672">=</span> rootA;
  }  <span style="color:#75715e">// 合并两棵根节点不同的树!
</span></code></pre></div></li>
<li>
<p>性能分析</p>
<p>构造函数的时间性能是 $O(numberOfElements)$ ; 查找函数时间性能 $O(h)$ ，其中 $h$ 是树高。合并函数的时间性能是 $O(1)$。假设一个系列的操作要进行 $u$ 次合并和 $f$ 次查找，因为每次合并前必须经过两次查找，所以时间性能为 $O(2f+u)=O(f+u)$。每一次的查找时间最多为 $\Theta(q)$ ,其中 $q$ 是执行查找之前合并操作的次数（最坏情况：每一次都在只有一个节点的树中找一棵，合并到最多元素的树上）。</p>
</li>
<li>
<p>优化</p>
<p><em><strong>合并函数的性能改进</strong></em>，利用 <strong>重量</strong> 和 <strong>高度</strong> 规则。</p>
<ul>
<li>重量：若根为 $i$ 的树的节点数少于根为 $j$ 的树的节点数，则将 $j$ 作为 $i$ 的父节点。否则将 $i$ 作为 $j$ 的父节点。</li>
<li>高度：若根为 $i$ 的树的高度少于根为 $j$ 的树的高度，则将 $j$ 作为 $i$ 的父节点。否则将 $i$ 作为 $j$ 的父节点。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">unionFindNode</span> {
  <span style="color:#66d9ef">bool</span> isRoot;  <span style="color:#75715e">// 若为真则表示是树的根节点
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> parent;  <span style="color:#75715e">// 当isRoot为真的时候表示该树的重量，否则表示双亲
</span><span style="color:#75715e"></span>  unionFindNode() {
    parent <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    isRoot <span style="color:#f92672">=</span> true;
  };
};

unionFindNode <span style="color:#f92672">*</span>node;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">initialize</span>(<span style="color:#66d9ef">int</span> numberOfElements) {
  <span style="color:#75715e">// 初始化numberOfElements棵树，每棵树包含一个元素
</span><span style="color:#75715e"></span>  node <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> unionFindNode
      [numberOfElements];  <span style="color:#75715e">// 自动调用默认构造函数构造这么多个元素
</span><span style="color:#75715e"></span>};

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">unite</span>(<span style="color:#66d9ef">int</span> rootA, <span style="color:#66d9ef">int</span> rootB) {
  <span style="color:#75715e">// 使用重量规则，合并根为不同的两棵树
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (node[rootA].parent <span style="color:#f92672">&lt;</span> node[rootB].parent) {
    <span style="color:#75715e">// 树a成为b的子树
</span><span style="color:#75715e"></span>    node[rootB].parent <span style="color:#f92672">+=</span> node[rootA].parent;
    node[rootA].isRoot <span style="color:#f92672">=</span> false;
    node[rootA].parent <span style="color:#f92672">=</span> rootB;  <span style="color:#75715e">// 父节点
</span><span style="color:#75715e"></span>  } <span style="color:#66d9ef">else</span> {
    <span style="color:#75715e">// 反之
</span><span style="color:#75715e"></span>    node[rootA].parent <span style="color:#f92672">+=</span> node[rootB].parent;
    node[rootB].isRoot <span style="color:#f92672">=</span> false;
    node[rootB].parent <span style="color:#f92672">=</span> rootA;  <span style="color:#75715e">// 父节点
</span><span style="color:#75715e"></span>  }
};

</code></pre></div><p>用重量规则合并一棵 $p$ 个节点的树 $t$ ，其 <em><strong>最大高度为 $\lfloor \log_2p \rfloor+1$</strong></em> ,若从单元素集合出发，混合执行 $u$ 次合并和 $f$ 次查找，则每个集合不会超过 $u+1$ 个元素。虽然合并的操作时间有所增加，但是仍在一个常数范围内，查找时间性能为 $O(\lfloor\log_2\left(u+1\right)\rfloor+1)=O(log u)$ 。那么总的时间性能为 $O(u+f log u=O(flogu))$(因为我们假定 $f&gt;u$)。</p>
<p><em><strong>查找函数的性能改进</strong></em></p>
<ul>
<li>路径紧缩：从待查节点到根节点的路径上，所有节点的<code>parent</code>指针都改为指向根节点。</li>
<li>路径分割：除了根节点以及根节点的子节点外，所有的节点<code>parent</code>指针都改为指向各自的祖父。</li>
<li>路径对折：从待查节点到根节点的路径上，除了根节点以及根节点的子节点外，所有的节点<code>parent</code>指针都改为指向各自的祖父。</li>
</ul>
<p><img src="/images/blogFigure/binaryTree/figure11.png" alt="路径紧缩前的简单树"></p>
<!-- raw HTML omitted -->
<p><img src="/images/blogFigure/binaryTree/figure12.png" alt="路径紧缩后的简单树"></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">// 路径紧缩
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">find</span>(<span style="color:#66d9ef">int</span> theElement) {
  <span style="color:#75715e">// 返回元素所在树的根
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 紧缩从元素 theElement到根的路径
</span><span style="color:#75715e"></span>
  <span style="color:#75715e">// theRoot最终是树的根
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> theRoot <span style="color:#f92672">=</span> theElement;
  <span style="color:#75715e">// 找到树的根 theRoot
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>node[theRoot].isRoot) theRoot <span style="color:#f92672">=</span> node[theRoot].parent;  <span style="color:#75715e">//网上移一层
</span><span style="color:#75715e"></span>
  <span style="color:#75715e">// 紧缩从theElement到root的路径
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> currentNode <span style="color:#f92672">=</span> theElement;
  <span style="color:#66d9ef">while</span> (currentNode <span style="color:#f92672">!=</span> theRoot) {
    <span style="color:#66d9ef">int</span> parentNode <span style="color:#f92672">=</span> node[currentNode].parent;
    node[currentNode].parent <span style="color:#f92672">=</span> theRoot;  <span style="color:#75715e">// 移到第二层
</span><span style="color:#75715e"></span>    currentNode <span style="color:#f92672">=</span> parentNode;            <span style="color:#75715e">// 移到原来的父节点
</span><span style="color:#75715e"></span>  }
  <span style="color:#66d9ef">return</span> theRoot;
};
</code></pre></div></li>
</ol>
<p>路径紧缩的使得单次 <code>find</code> 的时间有所增加（2倍,也是常数范围的增加），但是总的来说路径紧缩可以使其 <code>find</code> 函数的时间性能从 <em><strong>对数级</strong></em> 降低到 <em><strong>常数级</strong></em> 即 $O(1)$ 。于是总的时间性能为 $O(u+f)=O(f)$ （假定 $f&gt;u$）。</p>

    </div>

    <div class="post-copyright">
             
            <p class="copyright-item">
                <span>Author:</span>
                <span>小羊Sean </span>
                </p>
            
           
             
            <p class="copyright-item">
                    <span>Link:</span>
                    <a href=https://seanchan0901.github.io/2020/binarytree/>https://seanchan0901.github.io/2020/binarytree/</span>
            </p>
            
             
            <p class="copyright-item lincese">
                本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
            </p>
            
    </div>

  
    <div class="post-tags">
        
            <section>
            <i class="iconfont icon-tag"></i>Tag(s): 
            
            <span class="tag"><a href="https://seanchan0901.github.io/tags/data-structures/">
                    #Data Structures</a></span>
            
            <span class="tag"><a href="https://seanchan0901.github.io/tags/binary-tree/">
                    #binary tree</a></span>
            
            <span class="tag"><a href="https://seanchan0901.github.io/tags/union-find/">
                    #union-find</a></span>
            
            </section>
        
        <section>
                <a href="javascript:window.history.back();">back</a></span> · 
                <span><a href="https://seanchan0901.github.io">home</a></span>
        </section>
    </div>

    <div class="post-nav">
         
        
    </div>

    <div class="post-comment">
          
                 

<div id="vcomments"></div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script>

<script type="text/javascript">
  new Valine({
      el: '#vcomments' ,
      appId: 'aIoQ1Lc6ML2oeJYA92Q58gf0-gzGzoHsz',
      appKey: 'MqrNP4ET5Ak7C6gn87MNw25R',
      notify: 'true', 
      verify: 'true', 
      avatar:'mm', 
      placeholder: '说点什么吧...',
      visitor: 'true'
  });
</script>
                 
          
    </div>
</article>
          </div>
		   </main>
      <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span itemprop="copyrightYear">2020 - 2020</span>
        
        <span class="with-love">
    	 <i class="iconfont icon-love"></i> 
         </span>
         
            <span class="author" itemprop="copyrightHolder"><a href="https://seanchan0901.github.io">小羊Sean</a> | </span> 
         

         
        <span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow">Hugo</a> & <a href="https://github.com/liuzc/leaveit" target="_blank" rel="external nofollow">LeaveIt</a></span> 
        
        <span id="busuanzi_container_site_pv">
         本站访问量：<span id="busuanzi_value_site_pv"></span>次
        </span>
        &nbsp;
        <span id="busuanzi_container_site_uv">
         您是本站第 <span id="busuanzi_value_site_uv"></span> 位访问者
        </span>
    </div>
</footer>












    
     <link href="//lib.baomitu.com/lightgallery/1.6.11/css/lightgallery.min.css" rel="stylesheet">  
      
     <script src="/js/vendor_gallery.min.js" async="" ></script>
    
  




<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js"
integrity="sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx" 
crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/auto-render.min.js"
integrity="sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe"
crossorigin="anonymous"
onload="renderMathInElement(document.body,{delimiters: [{left: '$$', right: '$$', display: true},{left: '$', right: '$', display: false}]});"></script>
     </div>
  </body>
</html>
